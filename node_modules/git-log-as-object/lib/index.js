"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Log_1 = require("./Log");
const Diff_1 = require("./Diff");
const CommitBuilder_1 = require("./CommitBuilder");
/**
 *  Asynchronously fetches the metadata of all commits within a particular reference range.
 *  @param options An object containing (optionally,) the path of the repo's root directory, the
 *    starting and ending refs of the commit range, and the names of any extra attributes to include
 *    in the resulting report.
 *  @return A Promise for an array of objects containing the metadata of each commit in the range.
 */
function gitLog(options) {
    return __awaiter(this, void 0, void 0, function* () {
        const { dir, commitBuilder, includeDiff, rangeString } = prepare(options);
        const data = yield Log_1.Log.fetch(rangeString, commitBuilder.formatString, dir);
        const log = commitBuilder.buildAll(data);
        if (includeDiff) {
            const applyDiff = (commit) => Diff_1.Diff.make(commit, dir).then(diff => Object.assign(commit, { diff }));
            return Promise.all(log.map(applyDiff));
        }
        return log;
    });
}
exports.gitLog = gitLog;
/**
 *  Synchronously fetches the metadata of all commits within a particular reference range.
 *  @param options An object containing (optionally,) the path of the repo's root directory, the
 *    starting and ending refs of the commit range, and the names of any extra attributes to include
 *    in the resulting report.
 *  @return An array of objects containing the metadata of each commit in the range.
 */
function gitLogSync(options) {
    const { dir, commitBuilder, includeDiff, rangeString } = prepare(options);
    const data = Log_1.Log.fetchSync(rangeString, commitBuilder.formatString, dir);
    const log = commitBuilder.buildAll(data);
    if (includeDiff) {
        for (const commit of log) {
            const diff = Diff_1.Diff.makeSync(commit, dir);
            Object.assign(commit, { diff });
        }
    }
    return log;
}
exports.gitLogSync = gitLogSync;
function prepare(options = {}) {
    const dir = (typeof options.dir === 'string') ? options.dir : process.cwd();
    const optionalKeys = new Set(options.includeKeys);
    const includeDiff = optionalKeys.delete('diff');
    const commitBuilder = new CommitBuilder_1.CommitBuilder(optionalKeys);
    const rangeString = getRangeString(options.startRef, options.endRef);
    return { dir, commitBuilder, includeDiff, rangeString };
}
function getRangeString(startRef, endRef = 'HEAD') {
    if (startRef !== undefined) {
        return `${startRef}..${endRef}`;
    }
    return endRef;
}
